#include "features.h"

#include <string.h>
#include <sys/time.h>
#include <stdio.h>
#include <stdlib.h>

#include <bfsys/bf_sal/bf_sys_mem.h>

#include "../autogenerated/table_handles.h"
#include "../flow_db/flow_db.h"
#include "../datastructures/session_hashtable.h"


static void process_and_age_feature(feature_register_t *register_info);

static inline void process_feature(feature_register_t *register_info);


feature_register_t register_count = {
		.reg_id = PACKET_COUNT_REG,
		.name = "count",
		.on_egress = pkt_count_reg_on_egress,
		.table_hdl = pkt_count_reg_handle,
		.process_register = process_and_age_feature,
		.read_fn = p4_pd_marina_data_plane_register_range_read_pkt_count_reg,
		.write_fn = p4_pd_marina_data_plane_register_write_pkt_count_reg,
		.reset_fn = p4_pd_marina_data_plane_register_reset_all_pkt_count_reg,
};
feature_register_t register_size_log = {
		.reg_id = SIZE_LOG_REG,
		.name = "size_log",
		.on_egress = size_log_reg_on_egress,
		.table_hdl = size_log_reg_handle,
		.process_register = process_feature,
		.read_fn = p4_pd_marina_data_plane_register_range_read_size_log_reg,
		.write_fn = p4_pd_marina_data_plane_register_write_size_log_reg,
		.reset_fn = p4_pd_marina_data_plane_register_reset_all_size_log_reg,
};
feature_register_t register_size_log_square = {
		.reg_id = SIZE_LOG_SQUARE_REG,
		.name = "size_log_square",
		.on_egress = size_log_square_reg_on_egress,
		.table_hdl = size_log_square_reg_handle,
		.process_register = process_feature,
		.read_fn = p4_pd_marina_data_plane_register_range_read_size_log_square_reg,
		.write_fn = p4_pd_marina_data_plane_register_write_size_log_square_reg,
		.reset_fn = p4_pd_marina_data_plane_register_reset_all_size_log_square_reg,
};

feature_register_t register_size_log_cube = {
		.reg_id = SIZE_LOG_CUBE_REG,
		.name = "size_log_cube",
		.on_egress = size_log_cube_reg_on_egress,
		.table_hdl = size_log_cube_reg_handle,
		.process_register = process_feature,
		.read_fn = p4_pd_marina_data_plane_register_range_read_size_log_cube_reg,
		.write_fn = p4_pd_marina_data_plane_register_write_size_log_cube_reg,
		.reset_fn = p4_pd_marina_data_plane_register_reset_all_size_log_cube_reg,
};

feature_register_t register_iat_log = {
		.reg_id = IAT_LOG_REG,
		.name = "iat_log",
		.on_egress = iat_log_reg_on_egress,
		.table_hdl = iat_log_reg_handle,
		.process_register = process_feature,
		.read_fn = p4_pd_marina_data_plane_register_range_read_iat_log_reg,
		.write_fn = p4_pd_marina_data_plane_register_write_iat_log_reg,
		.reset_fn = p4_pd_marina_data_plane_register_reset_all_iat_log_square_reg,
};

//feature_register_t register_iat_log_max = {
//		.reg_id = IAT_LOG_MAX,
//		.name = "iat_log_max",
//		.on_egress = iat_log_max_reg_on_egress,
//		.table_hdl = iat_log_max_reg_handle,
//		.register_width = REG_U8,
//		.process_register = process_feature_val_uint8,
//		.read8_fn = p4_pd_marina_data_plane_register_range_read_iat_log_max_reg,
//		.write8_fn = p4_pd_marina_data_plane_register_write_iat_log_max_reg,
//		.reset_fn = p4_pd_marina_data_plane_register_reset_all_iat_log_max_reg,
//};

//feature_register_t register_iat_log_min = {
//		.reg_id = IAT_LOG_MIN,
//		.name = "iat_log_min",
//		.on_egress = iat_log_min_reg_on_egress,
//		.table_hdl = iat_log_min_reg_handle,
//		.register_width = REG_U8,
//		.process_register = process_feature_val_uint8,
//		.read8_fn = p4_pd_marina_data_plane_register_range_read_iat_log_min_reg,
//		.write8_fn = p4_pd_marina_data_plane_register_write_iat_log_min_reg,
//		.reset_fn = p4_pd_marina_data_plane_register_reset_all_iat_log_min_reg,
//};

feature_register_t register_iat_log_square = {
		.reg_id = IAT_LOG_SQUARE_REG,
		.name = "iat_log_square",
		.on_egress = iat_log_square_reg_on_egress,
		.table_hdl = iat_log_square_reg_handle,
		.process_register = process_feature,
		.read_fn = p4_pd_marina_data_plane_register_range_read_iat_log_square_reg,
		.write_fn = p4_pd_marina_data_plane_register_write_iat_log_square_reg,
		.reset_fn = p4_pd_marina_data_plane_register_reset_all_iat_log_square_reg,
};

feature_register_t register_iat_log_cube = {
		.reg_id = IAT_LOG_CUBE_REG,
		.name = "iat_log_cube",
		.on_egress = iat_log_cube_reg_on_egress,
		.table_hdl = iat_log_cube_reg_handle,
		.process_register = process_feature,
		.read_fn = p4_pd_marina_data_plane_register_range_read_iat_log_cube_reg,
		.write_fn = p4_pd_marina_data_plane_register_write_iat_log_cube_reg,
		.reset_fn = p4_pd_marina_data_plane_register_reset_all_iat_log_cube_reg,
};

feature_register_t register_last_timestamp = {
		.name = "iat_last_timestamp",
		.on_egress = iat_last_timestamp_reg_on_egress,
		.table_hdl = iat_last_timestamp_reg_handle,
		.process_register = NULL,
		.read_fn = p4_pd_marina_data_plane_register_range_read_iat_last_timestamp_reg,
		.write_fn = p4_pd_marina_data_plane_register_write_iat_last_timestamp_reg,
		.reset_fn = p4_pd_marina_data_plane_register_reset_all_iat_last_timestamp_reg,
};

//feature_register_t register_tcp_retransmission = {
//		.reg_id = TCP_RETRANSMISSION,
//		.name = "tcp_retransmission",
//		.on_egress = ret_count_reg_on_egress,
//		.table_hdl = ret_count_reg_handle,
//		.process_register = process_feature,
//		.read_fn = p4_pd_marina_data_plane_register_range_read_ret_count_reg,
//		.write_fn = p4_pd_marina_data_plane_register_write_ret_count_reg,
//		.reset_fn = p4_pd_marina_data_plane_register_reset_all_ret_count_reg,
//};

volatile bool dataplane_new_features;
pthread_spinlock_t dataplane_feature_lock;
pthread_cond_t dataplane_new_features_cond;
pthread_mutex_t dataplane_new_features_lock;

uint32_t last_flow_update[FEATURE_SIZE];


#define SWAP_DP_BUFFER(reg) {                                 \
    void *temp = (reg)->last_data_plane_value;                \
    (reg)->last_data_plane_value = (reg)->data_plane_values;  \
    (reg)->data_plane_values = temp;                          \
    }

/*
 * perform array zeroing for one feature
 */
static inline void prepare_feature(feature_register_t *register_info) {
	DEBUG_LOG("Preparing feature %s", register_info->name)
	register_info->data_plane_values = register_info->buffer_a;
	register_info->last_data_plane_value = register_info->buffer_b;
	memset(register_info->buffer_a, 0, sizeof(uint32_t) * FEATURE_SIZE);
	memset(register_info->buffer_b, 0, sizeof(uint32_t) * FEATURE_SIZE);
	memset(register_info->values, 0, sizeof(uint64_t) * FEATURE_SIZE);
	memset(last_flow_update, 0, sizeof(uint32_t) * FEATURE_SIZE);
}

static inline int sync_feature(pipe_sess_hdl_t sess_hdl, feature_register_t *register_info) {
	static const dev_target_t PIPE_MGR_ALL_PIPES = {
			.device_id = 0,
			.dev_pipe_id = BF_DEV_PIPE_ALL,
	};
	pipe_status_t status;
	status = pipe_stful_database_sync(sess_hdl, PIPE_MGR_ALL_PIPES, register_info->table_hdl, NULL, NULL);
	if (status != PIPE_SUCCESS) {
		ERROR_LOG("Error syncing feature %s: %s", register_info->name, pipe_str_err(status))
		return ERR_SWITCH;
	}
	return SUCCESS;
}

static inline int read_feature(pipe_sess_hdl_t sess_hdl, feature_register_t *register_info) {
	int actually_read;
	int value_count;
	p4_pd_status_t status;

	SWAP_DP_BUFFER(register_info)

	status = register_info->read_fn(
			sess_hdl, ALL_PIPES,
			0, MAX_FLOWS, 0,
			&actually_read,
			register_info->data_plane_values,
			&value_count
	);

	if (status) {
		ERROR_LOG("Error reading features: %s\n", pipe_str_err(status));
		return ERR_SWITCH;
	}
	// TODO handle actually_read and value_count
	return SUCCESS;
}


static inline void process_feature(feature_register_t *register_info) {
	for (int i = MIN_SESSION_ID; i < FEATURE_SIZE; i++) {
		register_info->values[i] += register_info->data_plane_values[i] -
									register_info->last_data_plane_value[i];
	}
}

static void process_and_age_feature(feature_register_t *register_info) {
	struct timespec ts;
	if (clock_gettime(CLOCK_MONOTONIC, &ts) == -1) {
		printf("Error getting monotonic clock\n");
		exit(1);
	}
	uint32_t now = ts.tv_sec;
	uint32_t timeout = now - FLOW_TIMEOUT;

	for (int i = MIN_SESSION_ID; i < FEATURE_SIZE; i++) {
		register_info->values[i] += register_info->data_plane_values[i] -
									register_info->last_data_plane_value[i];

		if ((register_info->data_plane_values[i] != register_info->last_data_plane_value[i]) ||
			(last_flow_update[i] == 0 && session_hashtable.egress_feature_to_session_id[i] != -1)) {
//			printf("id %d updated\n", i);
			last_flow_update[i] = now;
		}
		else if (last_flow_update[i] < timeout && session_hashtable.egress_feature_to_session_id[i] != -1) {
			packet_item_t item = {
					.args = {
							.flow_id = session_hashtable.egress_feature_to_session_id[i],
					},
					.command = PKT_TIMEOUT_FLOW,
			};
			if (packet_ringbuffer_put(&item) == 0) {
				last_flow_update[i] = 0;
			}
		}
	}
}

void set_new_flow_initial_timeout(uint32_t flow_id) {
	struct timespec ts;
	if (clock_gettime(CLOCK_MONOTONIC, &ts) == -1) {
		printf("Error getting monotonic clock\n");
		exit(1);
	}
	last_flow_update[flow_id] = ts.tv_sec;
}

/*
 * Zero out all feature arrays
 */
void prepare_features(pipe_sess_hdl_t sess_hdl) {
	STATIC_FEATURES_ARRAY
	for (int i = 0; i < NUM_FEATURES; i++) {
		for (int pipe = 0; pipe < NUM_PIPES; pipe++) {
			features[i]->reset_fn(sess_hdl, PIPES[pipe]);
			prepare_feature(features[i]);
		}
	}
}

/*
 * read all features from the data plane and compute the correct feature values for each flow
 */
void read_features(pipe_sess_hdl_t sess_hdl) {
	STATIC_FEATURES_ARRAY
	BENCH_PREPARE(a)

	BENCH_START(a)
	for (int i = 0; i < NUM_FEATURES; i++) {
		sync_feature(sess_hdl, features[i]);
	}
	BENCH_END(a, "Syncing features")

	BENCH_START(a)
	for (int i = 0; i < NUM_FEATURES; i++) {
		read_feature(sess_hdl, features[i]);
	}
	BENCH_END(a, "Reading features")

	BENCH_START(a)
	for (int i = 0; i < NUM_FEATURES; i++) {
		features[i]->process_register(features[i]);
	}
	BENCH_END(a, "Processing features")
}
